
# Практическая № 1
__ФИО__: Аникин Евгений Викторович   
__Вариант__: 4   
__Язык программирования__: Python    
# Постановка задачи
Разработать эмулятор для языка оболочки ОС. Необходимо сделать работу эмулятора как можно более похожей на работу в командной строке UNIX подобной ОС. 

# Ход решения

## Этап 1. REPL ##
__Цель__: создать минимальный прототип. Большинство функций в нем пока представляют собой заглушки, но диалог с пользователем уже поддерживается.  
__Требования__: 
1. Приложение должно быть реализовано в форме консольного интерфейса (CLI). 
2. Приглашение к вводу должно содержать имя VFS.
3. Реализовать парсер, который корректно обрабатывает аргументы в кавычках. 
4. Сообщить об ошибке выполнения команд (неизвестная команда, неверные аргументы). 
5. Реализовать команды-заглушки, которые выводят свое имя и аргументы: ls, cd. 
6. Реализовать команду exit. 
7. Продемонстрировать работу прототипа в интерактивном режиме. Необходимо показать примеры работы всей реализованной функциональности, включая обработку ошибок. 
8. Результат выполнения этапа сохранить в репозиторий стандартно 
оформленным коммитом.

## Этап 2. Конфигурация ##
__Цель__: сделать эмулятор настраиваемым, то есть поддержать ввод параметров пользователя в приложение. Организовать для этого этапа отладочный вывод всех заданных параметров при запуске эмулятора.  
__Требования__: 
1. Параметры командной строки: 
    – Путь к физическому расположению VFS. 
    – Путь к стартовому скрипту. 
2. Стартовый скрипт для выполнения команд эмулятора: выполняет команды последовательно, ошибочные строки пропускает. При выполнении скрипта на экране отображается как ввод, так и вывод, имитируя диалог с пользователем. 
3. Сообщить об ошибке во время исполнения стартового скрипта. 
4. Создать несколько скриптов реальной ОС, в которой выполняется эмулятор. Включить в каждый скрипт вызовы эмулятора для тестирования всех поддерживаемых параметров командной строки. 
5. Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом.

## Этап 3. VFS ## 
__Цель__: подключить виртуальную файловую систему (VFS).  
__Требования__: 
1. Все операции должны производиться в памяти. Запрещается распаковывать или иным образом модифицировать данные VFS, за исключением возможных служебных команд. 
2. Источником VFS является XML-файл. Для двоичных данных используется base64 или аналогичный формат. 
3. Необходимо реализовать команду vfs-save путь для сохранения состояния VFS на диск в исходном формате. 
4. Создать несколько скриптов реальной ОС, в которой выполняется эмулятор. Включить в каждый скрипт вызовы эмулятора для тестирования работы c различными вариантами VFS (минимальный, несколько файлов, не менее 3 уровней файлов и папок). 
5. Создать стартовый скрипт для тестирования всех реализованных на этом и прошлых этапах команд. Добавить туда примеры всех режимов команд, включая работу с VFS и обработку ошибок. 
6. Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом. 

## Этап 4. Основные команды ## 
__Цель__: поддержать команды, имитирующие работу в UNIX-подобной командной строке. 
__Требования__: 
1. Необходимо реализовать логику для ls и cd. 
2. Реализовать новые команды: find, tree, rev. 
3. Создать стартовый скрипт для тестирования всех реализованных на этом этапе команд. Добавить туда примеры всех режимов команд, включая работу с VFS и обработку ошибок. 
4. Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом.

## Этап 5. Дополнительные команды ##
__Цель__: поддержать более сложные команды, изменяющие состояние VFS, при этом модификации должны осуществляться только в памяти.  
__Требования__: 
1. Реализовать команды: rmdir. 
2. Создать стартовый скрипт для тестирования всех реализованных на этом этапе команд. Добавить туда примеры всех режимов команд, включая работу с VFS и обработку ошибок. 
3. Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом.